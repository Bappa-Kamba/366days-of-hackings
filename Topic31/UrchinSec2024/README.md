 # Cryptography Challenge  
 
 
Hello Been a while since i dropped a CTF writeup 


I plan to write about a Return-Oriented Programming (ROP) challenge I completed earlier this month, along with two interesting cryptography challenges I worked on over the weekend as part of the UrchinSec CTF. All of these challenges were rated medium difficulty by the event organizers.


## CHALLENGE 1:  WarmUp

```python

from sympy import mod_inverse

def generate_knapsack():
    knapsack = [1, 2]
    for i in range(6):
        knapsack.append(sum(knapsack) + 1)
    return knapsack

def convert_to_bits(message):
    bits = []
    for char in message:
        char_bits = bin(ord(char))[2:].zfill(8)
        bits.extend([int(b) for b in char_bits])
    return bits

def encrypt_message(message, knapsack, m, n):
    bits = convert_to_bits(message)
    chunk_size = len(knapsack)
    chunks = [bits[i:i + chunk_size] for i in range(0, len(bits), chunk_size)]
    ciphertext = []
    for chunk in chunks:
        if len(chunk) < chunk_size:
            chunk += [0] * (chunk_size - len(chunk))
        c_value = sum(k * b for k, b in zip(knapsack, chunk))
        encrypted_value = (c_value * n) % m
        ciphertext.append(encrypted_value)
    return ciphertext

k = [1, 2, 4, 8, 16, 32, 64, 128]




if __name__ == "__main__":
    message = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    knapsack = generate_knapsack()
    m = 257
    n = random.randint(-1000, 1000)
    ciphertext = encrypt_message(message, knapsack, m, n)
    print("Ciphertext:", ciphertext)

```

```
Ciphertext: [251, 210, 197, 79, 48, 120, 179, 12, 197, 143, 107, 230, 230, 230, 89, 89, 107, 217, 217, 217, 80, 242, 158, 179, 25, 55, 210, 80, 88, 230, 107, 80, 43, 199, 43, 80, 30, 230, 251, 80, 125, 55, 25, 80, 48, 25, 204, 204, 204, 204, 215]

```

### SOLUTION

Let's go over how this ciphertext was generated. First, a variable called knapsack was created. This knapsack variable is then used along with a random number n and a modulus variable m = 257.

The goal here is to retrieve the original message from the given ciphertext generated using this algorithm.

The first thing I did was analyze the encrypt_message function, which performs the encryption. This function converts the message into bits and separates them into chunks of length len(knapsack). It then multiplies each chunk by the unknown variable n and applies the modulus.

The ciphertext we have is the result after this operation. 

```py
c_value = sum(k * b for k, b in zip(knapsack, chunk))
encrypted_value = (c_value * n) % m
```

Let's take a look at how the ciphertext is generated, each of the value of knapsack is multiplied by a bit of the chunk message 


there is a flaw in this (aparently ), lets consider this operation (c_value * n) % m , The key thing to note is if a modulus operation is performed on a smaller positiive number , it changes nothing about the result 

for example :

```
2 % 7 == 2
```

A potential flaw here lies in the knapsack value being set as [1, 2, 4, 8, 16, 32, 64, 128], since generate_knapsack() returns a static value. Recall that c_value is generated by summing the product of each knapsack value with corresponding bits (either 1 or 0). In the unlikely scenario where all bits are set to 1 (non-ASCII), c_value would be 255, which is less than the modulus.

This is where n helps resolve the issue: by multiplying c_value by n, it increases the value beyond the modulus, making the ciphertext harder to reverse.

## Finding n

n is an int between -1000 and  1000, not a large keyspace to bruteforce if you ask me , however its always important to do things more efficiently "when you can". 

since I know part of the plaintext (what the flag begins with) and i can use that to derive the n  used in the equation that provides the equivalent cipher.

**Note: every flag starts with "urchinsec"**
 
#### encrypting my own flag

  First i converted the first 2 characters to binary as done in the encryption algorithm above

   ```python
     u = [0, 1, 1, 1, 0, 1, 0, 1]
	   r = [0, 1, 1, 1, 0, 0, 1, 0]
   ```

  then i got their value of c_value

  ```
     sum(k * b for k, b in zip(knapsack, r))
     u ==== 174
     r === 78
 ```
     ciphertext = [251, 210, 197, 79, 48, 120, 179, 12, 197, 143, 107, 230, 230, 230, 89, 89, 107, 217, 217, 217, 80, 242, 158, 179, 25, 55, 210, 80, 88, 230, 107, 80, 43, 199, 43, 80, 30, 230, 251, 80, 125, 55, 25, 80, 48, 25, 204, 204, 204, 204, 215]


  Then i asked what value of n when multiplied with the u and r equivalent will provide their ciphertext equivalence 251, 210

```
	 for n in range(-1000, 1000):
	    if ((174 * n) % 257 == 251) and ((78 * n) % 257 == 210):
	       print(i)
```

   Turns out , there are a couple of possible values of n , i chose 62

 ### Finding plaintext 

 now that we know n, knapsack(k), m ... the only unknown variable is the plaintext.

 so i had to ask the next question again, what ascii character (32, 127) would provide the ciphertext given using the algorithm provided to us with all the variables accounted for 

```
m = 257
ola = ''
n = 64
ciphertext = [251, 210, 197, 79, 48, 120, 179, 12, 197, 143, 107, 230, 230, 230, 89, 89, 107, 217, 217, 217, 80, 242, 158, 179, 25, 55, 210, 80, 88, 230, 107, 80, 43, 199, 43, 80, 30, 230, 251, 80, 125, 55, 25, 80, 48, 25, 204, 204, 204, 204, 215]

for j in ciphertext:
    for i in range(32, 127):
        chunk = convert_to_bits(chr(i))
        c_value = sum(k * b for k, b in zip(knapsack, chunk))
        if ((c_value * n) % m) == j:
            ola+=(chr(i))


print(ola)
```




============================================================



## Tr3ppl3 Stuffs


```
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, bytes_to_long

with open('flag.txt', 'rb') as f:
    flag = f.read()

p = getPrime(1024)
q = getPrime(1024)
r = getPrime(1024)

n1 = p * q
n2 = p * r
n3 = q * r

moduli = [n1, n2, n3]

e = 65537
c = bytes_to_long(flag)

for n in moduli:
    c = pow(c, e, n)

print("Encrypted message:", c)

with open('public-key.txt', 'w') as f:
    f.write(f'n1: {n1}\n')
    f.write(f'n2: {n2}\n')
    f.write(f'n3: {n3}\n')
    f.write(f'e: {e}\n')
    f.write(f'c: {c}\n')

```


### RSA ?

This other challenge howerver follows the basic RSA encryption equation,  \plaintext raise to power e modulus multiplication of 2 prime numbers (p, q)

C = M**e mod N.

yh our entire internet rest on this simple math lol, the security of this lies in the dificulty of how difficult it will be to factorize multiplication of two prime numbers without bruteforce


to decrypt , we need to know the value of the two prime numbers that took path in the encryption (p, q), deduct one from each and multiply them (p-1)(q-1), then take inverse of e mod this multiplication, let's call the result d 


to get the plaintext , we then multiply the ciphertext with d modulus of n (p*q)

glad thats out of the way, i didnt write the math its here ....

remember the security of this relies on the value of p and q.

In the flag encyption above, we can see p , q and r were generated with getPrime(1024), 1024 bytes is definately not bruteforceable , so gettig p, r and q that way is out of question


however, in there genius implementation they encrypted the plaintext thrice , using 3 public keys  and provided us with it 

```
n1 = p * q
n2 = p * r
n3 = q * r

```


why is this a bad idea ? ,  GCD or HCF

# GCD (Greatest Common Divisor ) also known as highest common factor

This is the largest integer that divides two variable . The greatest common divisor of any two distint prime numbers is 1. however in a situation like above

n1 (pq) and n2 (pr), these two numbers share a GCD of p as they are both divisible by only p



To retrive variable p, q and r .... 

pq and pr share a common divisor of p
pr and qr share a common divisor of r
qr and pq share a common divisor of q

There are two common algorithms used for GCD, euclidean algorithm (simpler but slower) and Lehmer's GCD algorithm (faster for large numbers )


check implementation here : https://gist.github.com/cmpute/baa545f0c2b6be8b628e9ded3c19f6c1



 
After retrieving the value of p, q, and r , we can proceed with the decryption, 

remember the ciphertext was first encrypted with n1 followed by n2 then n3 , to decrypt we have to reverse the order. First decrypt from n3 followed by n2 then n1.


d = e−1 mod (p − 1)(q − 1).

 Decoding: m = Md mod N.


```
from sympy import mod_inverse

	def decrypt(p, q):

		N = p * q

		phi_N = (p - 1) * (q - 1)

		# Step 3: Calculate d, the modular inverse of e modulo phi(N)
		d = mod_inverse(e, phi_N)

		# Step 4: Decode M by calculating m = M^d mod N
		m = pow(M, d, N)

		return m

	```

